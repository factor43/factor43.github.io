---
layout: post
author: sjl
title: It’s what’s on screen that matters, right?
---

A project I’ve been working on recently is a bit of a beast. It has a pretty large and sprawling codebase with a long history. Code quality is.. shall we say, a little lacking. (Y’know, all those attributes like efficiency, maintainability, extensibility etc. that are sometimes a little hard to quantify).

There are reasons for this of course, as there always is. Commercial pressures to continually release significant new updates with more features and content takes precedent over any type of refactoring or other maintenance.

But while the codebase is a little rough around the edges, the actual finished product is loved by a huge number of players, making it more successful than anything else I’ve worked on.

This troubles me. It seems a little… unjust. Shouldn’t great code mean a great product? And shouldn’t poor code result is a sub-par product? Clearly, not always.

I’ve worked in codebases that were cleaner, better structured, with more useful documentation – but that hasn’t necessarily translated into a good game or product.

So on the one hand, users don’t know or care what the underlying code looks like, and you sometimes hear people say it’s “What’s on screen that matters”, but I think that’s only partially true.

Players obviously are affected by the quality of underlying code – they’re more likely to experience bugs that slip past QA, they can be hit be performance issues, and even the extensibility of the codebase (or lack thereof) means that proposed features may not even be feasible while other things take much longer due to inflexibilities.

I think the relationship between code quality and end product quality is imperfect and fuzzy. The latter is the one that ultimately matters and code quality is but one contributing factor that can help or hinder that end goal.

But there are actually other reasons to strive for quality code from the perspective of those who spend their lives immersed in: Firstly, high quality code is more enjoyable and satisfying to work with. It’s nice when things just slot in and work because the code is flexible and adaptable. Conversely, it can be frustrating when something is more difficult or complex than you think it really should be. And there’s another reason too: you can take more easily take pride in what you’re creating when it’s well crafted and carefully engineered.